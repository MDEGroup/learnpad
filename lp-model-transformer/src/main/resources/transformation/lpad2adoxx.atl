-- @nsURI LPAD=http://learnpad.eu
-- @nsURI ADOXX=http://www.ado.org

module lpad2ado;
create OUT: ADOXX from IN: LPAD;

-- Standardization of names
helper def: UNDEFINED: String = 'undef';
helper def: mapModelType: Map(String, String) =
	Map{('bpmn', 'Business process diagram (BPMN 2.0)'),
		    ('cm', 'Competency model'),
		    ('bmm', 'BMM'),
		    ('dkm', 'Document and Knowledge model'),
		    ('os', 'Organizational structure'),
		    ('mso', 'Model Set Overview')};
helper def: processedBPMNElementType: Sequence(String) =
	Sequence{'Process', 'SubProcess', 'LaneSet', 'Lane', 'StartEvent', 'EndEvent',
			'Task', 'SendTask', 
			'Gateway', 'ExclusiveGateway', 'InclusiveGateway', 'ParallelGateway',
			'BoundaryEvent', 'IntermediateCatchEvent', 'CallActivity', 'DataObject',
			'InputOutputSpecification', 'DataInput', 'DataOutput', 'InputSet', 'OutputSet',
			'CancelEventDefinition', 'CompensateEventDefinition'};
helper def: processedBPMNFlowType: Sequence(String) =
	Sequence{'SequenceFlow', 'MessageFlow', 'DataAssociation'};
helper def: processedCompetencyElementType: Sequence(String) =
			Sequence{'CompetencyGroup', 'Competency'};
helper def: processedDocumenntElementType: Sequence(String) =
			Sequence{'Groups', 'Document'};
			

-- Context Utils Functions
helper context OclAny def: getType: String =
	if (self.oclIsUndefined()) then
		''
	else
		self.oclType().toString().substring(6,self.oclType().toString().size())
	endif;
	
helper def: connectorID: Integer = 0;


helper def: modelsType: ADOXX!MODELSType = 
	OclUndefined;

helper def: overviewModels: ADOXX!INTERREFType = 
	OclUndefined;

-- get the parent model id of a BPMN element
helper def: getParentModelID(current: OclAny ): String =
	if (current.refImmediateComposite().oclIsUndefined()) then
		thisModule.UNDEFINED
	else
		if ((current.refImmediateComposite().oclIsTypeOf(LPAD!BPMNModel)) or
			(current.refImmediateComposite().oclIsTypeOf(LPAD!CompetencyModel)) or
			(current.refImmediateComposite().oclIsTypeOf(LPAD!DKModel)) or
			(current.refImmediateComposite().oclIsTypeOf(LPAD!OrganisationalModel)) or
			(current.refImmediateComposite().oclIsTypeOf(LPAD!KPIModel)) or
			(current.refImmediateComposite().oclIsTypeOf(LPAD!BMMModel)))
		then
			current.refImmediateComposite().id
		else
			thisModule.getParentModelID(current.refImmediateComposite())
		endif
	endif;

-- get the parent MODELType of a BPMN element  
helper context OclAny def: getParentMODELType: ADOXX!MODELType = 
	thisModule.modelsType.mODEL->select(i | i.id=thisModule.getParentModelID(self)).first();

-- documentation helper
helper context OclAny def: BPMNDocumentation: String =
	if (self.oclIsKindOf(LPAD!BaseElement)) then
		if (not self.documentation.oclIsUndefined()) then
			if (self.documentation->collect(i | i.description).first()<>'') then
				self.documentation->collect(i | i.description).first()
			else
				self.documentation->collect(i | i.text).first()
			endif
		else
			''
		endif
	else
		''
	endif;

-- version helper
helper context OclAny def: getVersion: String = 
	if (self.version.oclIsUndefined()) then
		''
	else
		self.version
	endif;

-- name Model Set Overview helper
helper context LPAD!LPAdRoot def: getModelSetOverViewName: String = 
	if (self.name.oclIsUndefined()) then
		'Model Set Overview'
	else
		'Model Set Overview - '+self.name
	endif;

-- name ModelSet helper
helper context LPAD!LPAdRoot def: getModelSetName: String = 
	if (self.name.oclIsUndefined()) then
		'ModelSet'
	else
		'ModelSet - '+self.name
	endif;

entrypoint rule ModelOverview() {
	to
		t: ADOXX!ADOXMLType (
			mODELS <- t1
		),
		t1: ADOXX!MODELSType (
		)
	do {
		 --set the modelsType
		thisModule.modelsType <- t1;
	}
}

-------------------  LPAdRoot2ModelSetOverview  ----------------------
rule LPAdRoot2ModelSetOverview {
	from
		s: LPAD!LPAdRoot
	to
		t: ADOXX!MODELType (
			applib <- 'LearnPAd',
			libtype <- 'bp',
			version <- s.getVersion,
			id <- s.id,
			modeltype <- thisModule.mapModelType.get('mso'),
			name <- s.getModelSetOverViewName,
			iNSTANCE <- Sequence{i}
		),
		i: ADOXX!INSTANCEType (
			class <- 'ModelSet',
			name <- s.getModelSetName,
			id <- 'ModelSetID',
			aTTRIBUTE <- Sequence{a1, a2},
			iNTERREF <- Sequence{ir}
		),
		a1: ADOXX!ATTRIBUTEType (
			name <- 'Model Set ID',
			type <- 'STRING',
			value <- 'MODELSET_ID'
		),
		a2: ADOXX!ATTRIBUTEType (
			name <- 'Model Set Description',
			type <- 'LONGSTRING',
			value <- s.getModelSetName
		),
		ir: ADOXX!INTERREFType (
			name <- 'Model Set'	
		)
	do {
		thisModule.modelsType.mODEL <- thisModule.modelsType.mODEL.append(t);
		thisModule.overviewModels <- ir;
	}
}

rule createInsideConnector(source: OclAny, target: OclAny) {
	to
		c1: ADOXX!CONNECTORType (
			class <- 'Is inside',
			id <- 'conn.'+(thisModule.connectorID+1).toString(),
			fROM <- f1,
			tO <- t1
		),
		f1: ADOXX!FROMType (
			class <- source.getType,
			instance <- source.name
		),
		t1: ADOXX!TOType (
			class <- target.getType,
			instance <- target.name
		)
	do {
		source.getParentMODELType.cONNECTOR <- c1;
		
		thisModule.connectorID <- thisModule.connectorID +1;
	}
}

------------------------  BPMN2MODELType  ---------------------------
rule BPMN2MODELType {
	from
		s: LPAD!BPMNModel
	to
		t: ADOXX!MODELType(
			id <- s.id,
			name <- s.name,
			version <- s.getVersion,
			applib <- 'LearnPAd',
			libtype <- 'bp',
			modeltype <- thisModule.mapModelType.get('bpmn'),
			mODELATTRIBUTES <- Sequence{m}
		),
		m: ADOXX!MODELATTRIBUTESType(
			aTTRIBUTE <- Sequence{a}
		),
		a: ADOXX!ATTRIBUTEType (
			name <- 'Description',
			type <- 'STRING',
			value <- ''
		),
		iref: ADOXX!IREFType(
			tmodelname <- s.name,
			tmodeltype <- thisModule.mapModelType.get('bpmn'),
			type <- 'modelreference',
			tmodelver <- s.getVersion
		)
	do {
		thisModule.modelsType.mODEL <- thisModule.modelsType.mODEL.append(t);
		
		--append the iref definition to the model set overview reference
		thisModule.overviewModels.iREF <- thisModule.overviewModels.iREF.append(iref);
	}
}

-------------------------  BPMN Base Elements ------------------------------
abstract rule BPMNBaseElement {
	from
		s: LPAD!BaseElement ((thisModule.processedBPMNElementType.includes(s.getType)) and 
			(not s.name.oclIsUndefined()) 
			and (s.name.toString()<>''))			
	to
		i: ADOXX!INSTANCEType (
			class <- s.getType,
			id <- s.id,
			name <- s.name,
			aTTRIBUTE <- Sequence{a}
		),
		a: ADOXX!ATTRIBUTEType (
			name <- 'Description',
			type <- 'STRING',
			value <- s.BPMNDocumentation
		)
	do {
			--set the instances to parent model
			s.getParentMODELType.iNSTANCE <- i;	
			
			--relations from Base superclass
			thisModule.BPMNBaseConnector(s);
		}
}	

-----------------------------  BPMN Process -------------------------------
rule BPMNProcess2InstanceType extends BPMNBaseElement {
	from
		s: LPAD!Process
	do {
		--set the instances to parent model
		s.getParentMODELType.iNSTANCE <- i;
		
		--relations from Base superclass
		thisModule.BPMNBaseConnector(s);
		
		--relations from FlowElementsContainer superclass
		thisModule.BPMNFlowElementsContainerConnector(s);
		
		--relations from CallableElement superclass
		thisModule.BPMNCallableElementConnector(s);
	}
}

---------------------------  BPMN Sub-Process -----------------------------
rule BPMNSubProcess2InstanceType extends BPMNBaseElement {
	from
		s: LPAD!SubProcess
	do {
		--set the instances to parent model
		s.getParentMODELType.iNSTANCE <- i;
		
		--relations from Base superclass
		thisModule.BPMNBaseConnector(s);
		
		--relations from FlowElementsContainer superclass
		thisModule.BPMNFlowElementsContainerConnector(s);
		
		--relations from Activity superclass
		thisModule.BPMNActivityConnector(s);
	}
}

-----------------------------  BPMN LaneSet -------------------------------
rule BPMNLaneSet2InstanceType extends BPMNBaseElement {
	from
		s: LPAD!LaneSet
	do {
		--set the instances to parent model
		s.getParentMODELType.iNSTANCE <- i;
		
		--relations from Base superclass
		thisModule.BPMNBaseConnector(s);
		
		--relations from LaneSet
		thisModule.BPMNLaneSetConnector(s);
	}
}

------------------------------  BPMN Lane --------------------------------
rule BPMNLane2InstanceType extends BPMNBaseElement {
	from
		s: LPAD!Lane
	do {
		--set the instances to parent model
		s.getParentMODELType.iNSTANCE <- i;
		
		--relations from Base superclass
		thisModule.BPMNBaseConnector(s);
		
		--relations from Lane
		thisModule.BPMNLaneConnector(s);
	}
}

---------------------------  BPMN Start Event ----------------------------
rule BPMNStartEvent2InstanceType extends BPMNBaseElement {
	from
		s: LPAD!StartEvent
	do {
		--set the instances to parent model
		s.getParentMODELType.iNSTANCE <- i;
		
		--relations from Base superclass
		thisModule.BPMNBaseConnector(s);
		
		--relations from CatchEvent superclass
		thisModule.BPMNCatchEventConnector(s);
	}
}

-----------------------------  BPMN End Event -----------------------------
rule BPMNEndEvent2InstanceType extends BPMNBaseElement {
	from
		s: LPAD!EndEvent
	do {
		--set the instances to parent model
		s.getParentMODELType.iNSTANCE <- i;
		
		--relations from Base superclass
		thisModule.BPMNBaseConnector(s);
		
		--relations from ThrowEvent
		thisModule.BPMNThrowEventConnector(s);
	}
}

------------------------------  BPMN Task --------------------------------
rule BPMNTask2InstanceType extends BPMNBaseElement {
	from
		s: LPAD!Task
	do {
		--set the instances to parent model
		s.getParentMODELType.iNSTANCE <- i;
		
		--relations from Base superclass
		thisModule.BPMNBaseConnector(s);
		
		--relations from Task
		thisModule.BPMNTaskConnector(s);
		
		--relations from Activity superclass
		thisModule.BPMNActivityConnector(s);
	}
}

-----------------------------  BPMN SendTask -----------------------------
rule BPMNSendTask2InstanceType extends BPMNBaseElement {
	from
		s: LPAD!SendTask
	do {
		--set the instances to parent model
		s.getParentMODELType.iNSTANCE <- i;
		
		--relations from Base superclass
		thisModule.BPMNBaseConnector(s);
		
		--relations from Task
		thisModule.BPMNTaskConnector(s);
		
		--relations from Activity superclass
		thisModule.BPMNActivityConnector(s);
	}
}

-----------------------------  BPMN Gateway ------------------------------
rule BPMNGateway2InstanceType extends BPMNBaseElement {
	from
		s: LPAD!Gateway
	do {
		--set the instances to parent model
		s.getParentMODELType.iNSTANCE <- i;
		
		--relations from Base superclass
		thisModule.BPMNBaseConnector(s);
		
		--relations from FlowNode
		thisModule.BPMNFlowNodeConnector(s);
			
	}
}

------------------------  BPMN ExclusiveGateway --------------------------
rule BPMNExclusiveGateway2InstanceType extends BPMNBaseElement {
	from
		s: LPAD!ExclusiveGateway
	do {
		--set the instances to parent model
		s.getParentMODELType.iNSTANCE <- i;
		
		--relations from Base superclass
		thisModule.BPMNBaseConnector(s);
		
		--relations from FlowNode
		thisModule.BPMNFlowNodeConnector(s);
			
	}
}

--------------------------  BPMN InclusiveGateway -------------------------
rule BPMNInclusiveGateway2InstanceType extends BPMNBaseElement {
	from
		s: LPAD!InclusiveGateway
	do {
		--set the instances to parent model
		s.getParentMODELType.iNSTANCE <- i;
		
		--relations from Base superclass
		thisModule.BPMNBaseConnector(s);
		
		--relations from FlowNode
		thisModule.BPMNFlowNodeConnector(s);
			
	}
}

-------------------------  BPMN ParallelGateway --------------------------
rule BPMNParallelGateway2InstanceType extends BPMNBaseElement {
	from
		s: LPAD!ParallelGateway
	do {
		--set the instances to parent model
		s.getParentMODELType.iNSTANCE <- i;
		
		--relations from Base superclass
		thisModule.BPMNBaseConnector(s);
		
		--relations from FlowNode
		thisModule.BPMNFlowNodeConnector(s);
			
	}
}

---------------------------  BPMN BoundaryEvent ---------------------------
rule BPMNBoundaryEvent2InstanceType extends BPMNBaseElement {
	from
		s: LPAD!BoundaryEvent
	do {
		--set the instances to parent model
		s.getParentMODELType.iNSTANCE <- i;
		
		--relations from Base superclass
		thisModule.BPMNBaseConnector(s);
		
		--relations from CatchEvent
		thisModule.BPMNCatchEventConnector(s);
			
	}
}

----------------------  BPMN IntermediateCatchEvent ----------------------
rule BPMNIntermediateCatchEvent2InstanceType extends BPMNBaseElement {
	from
		s: LPAD!IntermediateCatchEvent
	do {
		--set the instances to parent model
		s.getParentMODELType.iNSTANCE <- i;
		
		--relations from Base superclass
		thisModule.BPMNBaseConnector(s);
		
		--relations from CatchEvent
		thisModule.BPMNCatchEventConnector(s);
			
	}
}

---------------------------  BPMN CallActivity ---------------------------
rule BPMNCallActivity2InstanceType extends BPMNBaseElement {
	from
		s: LPAD!CallActivity
	do {
		--set the instances to parent model
		s.getParentMODELType.iNSTANCE <- i;
		
		--relations from Base superclass
		thisModule.BPMNBaseConnector(s);
		
		--relations from CatchEvent
		thisModule.BPMNActivityConnector(s);
			
	}
}

---------------------------  BPMN DataObject -----------------------------
rule BPMNDataObject2InstanceType extends BPMNBaseElement {
	from
		s: LPAD!DataObject
	do {
		--set the instances to parent model
		s.getParentMODELType.iNSTANCE <- i;
		
		--relations from Base superclass
		thisModule.BPMNBaseConnector(s);
		
		--relations from CatchEvent
		thisModule.BPMNFlowElementsContainerConnector(s);
			
	}
}

----------------------  BPMN InputOutputSpecification --------------------
rule BPMNInputOutputSpecification2InstanceType extends BPMNBaseElement {
	from
		s: LPAD!InputOutputSpecification
	do {
		--set the instances to parent model
		s.getParentMODELType.iNSTANCE <- i;
		
		--relations from Base superclass
		thisModule.BPMNBaseConnector(s);
		
		--relations from InputOutputSpecification
		thisModule.BPMNInputOutputSpecificationConnector(s);
			
	}
}

------------------------------  BPMN DataInput ---------------------------
rule BPMNDataInput2InstanceType extends BPMNBaseElement {
	from
		s: LPAD!DataInput
	do {
		--set the instances to parent model
		s.getParentMODELType.iNSTANCE <- i;
		
		--relations from Base superclass
		thisModule.BPMNBaseConnector(s);
	}
}

------------------------------  BPMN DataOutput ---------------------------
rule BPMNDataOutput2InstanceType extends BPMNBaseElement {
	from
		s: LPAD!DataOutput
	do {
		--set the instances to parent model
		s.getParentMODELType.iNSTANCE <- i;
		
		--relations from Base superclass
		thisModule.BPMNBaseConnector(s);
	}
}

------------------------------  BPMN InputSet ----------------------------
rule BPMNInputSet2InstanceType extends BPMNBaseElement {
	from
		s: LPAD!InputSet
	do {
		--set the instances to parent model
		s.getParentMODELType.iNSTANCE <- i;
		
		--relations from Base superclass
		thisModule.BPMNBaseConnector(s);
	}
}

-----------------------------  BPMN OutputSet ----------------------------
rule BPMNDOutputSet2InstanceType extends BPMNBaseElement {
	from
		s: LPAD!OutputSet
	do {
		--set the instances to parent model
		s.getParentMODELType.iNSTANCE <- i;
		
		--relations from Base superclass
		thisModule.BPMNBaseConnector(s);
	}
}

-----------------------  BPMN CancelEventDefinition ----------------------
rule BPMNCancelEventDefinition2InstanceType extends BPMNBaseElement {
	from
		s: LPAD!CancelEventDefinition
	do {
		--set the instances to parent model
		s.getParentMODELType.iNSTANCE <- i;
		
		--relations from Base superclass
		thisModule.BPMNBaseConnector(s);
	}
}

--------------------  BPMN CompensateEventDefinition ---------------------
rule BPMNCompensateEventDefinition2InstanceType extends BPMNBaseElement {
	from
		s: LPAD!CompensateEventDefinition
	do {
		--set the instances to parent model
		s.getParentMODELType.iNSTANCE <- i;
		
		--relations from Base superclass
		thisModule.BPMNBaseConnector(s);
		
		--relations from CompensateEventDefinition
		thisModule.BPMNCompensateEventDefinitionConnector(s);
	}
}

---------------------------  BPMN SequenceFlow ---------------------------
rule BPMNSequenceFlow2ConnectorType {
	from
		s: LPAD!SequenceFlow((thisModule.processedBPMNFlowType.includes(s.getType)) and 
							(thisModule.processedBPMNElementType.includes(s.sourceRef.getType)) and
							(not s.sourceRef.name.oclIsUndefined()) and 
			 				(s.sourceRef.name.toString()<>'') and	
							(thisModule.processedBPMNElementType.includes(s.targetRef.getType)) and
							(not s.targetRef.name.oclIsUndefined()) and 
			 				(s.targetRef.name.toString()<>''))
	to
		c: ADOXX!CONNECTORType (
			class <- 'Subsequent', 
			id <- s.id,
			fROM <- f,
			tO <- t,
			aTTRIBUTE <- Sequence{a, a1}
		),
		f: ADOXX!FROMType (
			class <- s.sourceRef.getType,
			instance <- s.sourceRef.name
		),
		t: ADOXX!TOType (
			class <- s.targetRef.getType,
			instance <- s.targetRef.name
		),
		a: ADOXX!ATTRIBUTEType (
			name <- 'Description',
			type <- 'LONGSTRING',
			value <- ''
		),
		a1: ADOXX!ATTRIBUTEType (
			name <- 'Denomination',
			type <- 'STRING',
			value <- ''
		)
	do {
		--set the connector to parent model
		s.getParentMODELType.cONNECTOR<- c;
	}
}

----------------------------  BPMN MessageFlow ----------------------------
rule BPMNMessageFlow2ConnectorType {
	from
		s: LPAD!MessageFlow((thisModule.processedBPMNFlowType.includes(s.getType)) and 
							(thisModule.processedBPMNElementType.includes(s.sourceRef.getType)) and
							(not s.sourceRef.name.oclIsUndefined()) and 
			 				(s.sourceRef.name.toString()<>'') and	
							(thisModule.processedBPMNElementType.includes(s.targetRef.getType)) and
							(not s.targetRef.name.oclIsUndefined()) and 
			 				(s.targetRef.name.toString()<>''))
	to
		c: ADOXX!CONNECTORType (
			class <- 'Message Flow', 
			id <- s.id,
			fROM <- f,
			tO <- t
		),
		f: ADOXX!FROMType (
			class <- s.sourceRef.getType,
			instance <- s.sourceRef.name
		),
		t: ADOXX!TOType (
			class <- s.targetRef.getType,
			instance <- s.targetRef.name
		)
	do {
		--set the connector to parent model
		s.getParentMODELType.cONNECTOR<- c;
	}
}

---------------------  relations among BPMNElements ----------------------
helper def: connectBPMNElements(source: OclAny, target: OclAny): Boolean =
	if ((not source.name.oclIsUndefined()) and (source.name.toString()<>'')) and
	((not target.name.oclIsUndefined()) and (target.name.toString()<>'')) and
	(thisModule.processedBPMNElementType.includes(source.getType)) and
	(thisModule.processedBPMNElementType.includes(target.getType)) then
		thisModule.createInsideConnector(source, target)
	else
		false
	endif;

---------------------  BPMN Is inside relation rules ----------------------
rule BPMNBaseConnector(elem: OclAny) {
	do {
		if (elem.oclIsKindOf(LPAD!BaseElement)) {
			for (t in elem.documentation) {
				thisModule.connectBPMNElements(elem, t);
				thisModule.connectBPMNElements(t, elem);
			}		
		} 
	}
}

rule BPMNFlowElementsContainerConnector(elem: OclAny) {
	do {
		if (elem.oclIsKindOf(LPAD!FlowElementsContainer)) {
			for (t in elem.laneSets) {
				thisModule.connectBPMNElements(elem, t);
				thisModule.connectBPMNElements(t, elem);
			}
		
			for (t in elem.flowElements) {
				thisModule.connectBPMNElements(elem, t);
				thisModule.connectBPMNElements(t, elem);
			}	
		} 
	}
}

rule BPMNCallableElementConnector(elem: OclAny) {
	do {
		if (elem.oclIsKindOf(LPAD!CallableElement)) {
			if (not elem.ioSpecification.oclIsUndefined()) { 
				thisModule.connectBPMNElements(elem, elem.ioSpecification);
				thisModule.connectBPMNElements(elem.ioSpecification, elem);
			}
		} 
	}
}

rule BPMNThrowEventConnector(elem: OclAny) {
	do {
		if (elem.oclIsKindOf(LPAD!ThrowEvent)) {
			for (t in elem.dataInputs) {
				thisModule.connectBPMNElements(elem, t);
				thisModule.connectBPMNElements(t, elem);
			}
		
			for (t in elem.dataInputAssociation) {
				thisModule.connectBPMNElements(elem, t);
				thisModule.connectBPMNElements(t, elem);
			}
			
			for (t in elem.eventDefinitions) {
				thisModule.connectBPMNElements(elem, t);
				thisModule.connectBPMNElements(t, elem);
			}
			
			for (t in elem.eventDefinitionRefs) {
				thisModule.connectBPMNElements(elem, t);
				thisModule.connectBPMNElements(t, elem);
			}
			
			if (not elem.inputSet.oclIsUndefined()) { 
				thisModule.connectBPMNElements(elem, elem.childLaneSet);
				thisModule.connectBPMNElements(elem.childLaneSet, elem);
			}
		}
	}
}

rule BPMNInputOutputSpecificationConnector(elem: OclAny) {
	do {
		if (elem.oclIsKindOf(LPAD!InputOutputSpecification)) {
			for (t in elem.dataInputs) {
				thisModule.connectBPMNElements(elem, t);
				thisModule.connectBPMNElements(t, elem);
			}
		
			for (t in elem.inputSets) {
				thisModule.connectBPMNElements(elem, t);
				thisModule.connectBPMNElements(t, elem);
			}
			
			for (t in elem.dataOutputs) {
				thisModule.connectBPMNElements(elem, t);
				thisModule.connectBPMNElements(t, elem);
			}
			
			for (t in elem.outputSets) {
				thisModule.connectBPMNElements(elem, t);
				thisModule.connectBPMNElements(t, elem);
			}
		}
	}
}

rule BPMNActivityConnector(elem: OclAny) {
	do {
		if (elem.oclIsKindOf(LPAD!Activity)) {
			if (not elem.ioSpecification.oclIsUndefined()) { 
				thisModule.connectBPMNElements(elem, elem.ioSpecification);
				thisModule.connectBPMNElements(elem.ioSpecification, elem);
			}
			
			for (t in elem.boundaryEventRefs) {
				thisModule.connectBPMNElements(elem, t);
				thisModule.connectBPMNElements(t, elem);
			}
			
			for (t in elem.properties) {
				thisModule.connectBPMNElements(elem, t);
				thisModule.connectBPMNElements(t, elem);
			}
			
			for (t in elem.dataInputAssociations) {
				thisModule.connectBPMNElements(elem, t);
				thisModule.connectBPMNElements(t, elem);
			}
			
			for (t in elem.dataOutputAssociations) {
				thisModule.connectBPMNElements(elem, t);
				thisModule.connectBPMNElements(t, elem);
			}
		} 
	}
}

rule BPMNLaneSetConnector(elem: OclAny) {
	do {
		if (elem.oclIsKindOf(LPAD!LaneSet)) {
			for (t in elem.lanes) {
				thisModule.connectBPMNElements(elem, t);
				thisModule.connectBPMNElements(t, elem);
			}
		
			for (t in elem.representsOrganisationalUnit) {
				thisModule.connectBPMNElements(elem, t);
				thisModule.connectBPMNElements(t, elem);
			}
		} 
	}
}

rule BPMNLaneConnector(elem: OclAny) {
	do {
		if (elem.oclIsKindOf(LPAD!Lane)) {
			for (t in elem.partitionElement) {
				thisModule.connectBPMNElements(elem, t);
				thisModule.connectBPMNElements(t, elem);
			}
		
			for (t in elem.flowNodeRefs) {
				thisModule.connectBPMNElements(elem, t);
				thisModule.connectBPMNElements(t, elem);
			}
			
			for (t in elem.representsPerformer) {
				thisModule.connectBPMNElements(elem, t);
				thisModule.connectBPMNElements(t, elem);
			}
			
			for (t in elem.representsRole) {
				thisModule.connectBPMNElements(elem, t);
				thisModule.connectBPMNElements(t, elem);
			}
			
			for (t in elem.representsOrganisationalUnit) {
				thisModule.connectBPMNElements(elem, t);
				thisModule.connectBPMNElements(t, elem);
			}
			
			if (not elem.childLaneSet.oclIsUndefined()) { 
				thisModule.connectBPMNElements(elem, elem.childLaneSet);
				thisModule.connectBPMNElements(elem.childLaneSet, elem);
			}
		} 
	}
}

rule BPMNCatchEventConnector(elem: OclAny) {
	do {
		if (elem.oclIsKindOf(LPAD!CatchEvent)) {
			for (t in elem.dataOutputs) {
				thisModule.connectBPMNElements(elem, t);
				thisModule.connectBPMNElements(t, elem);
			}
			
			for (t in elem.dataOutputAssociation) {
				thisModule.connectBPMNElements(elem, t);
				thisModule.connectBPMNElements(t, elem);
			}
			
			for (t in elem.eventDefinitions) {
				thisModule.connectBPMNElements(elem, t);
				thisModule.connectBPMNElements(t, elem);
			}
			
			for (t in elem.eventDefinitionRefs) {
				thisModule.connectBPMNElements(elem, t);
				thisModule.connectBPMNElements(t, elem);
			}
			
			if (not elem.outputSet.oclIsUndefined()) { 
				thisModule.connectBPMNElements(elem, elem.childLaneSet);
				thisModule.connectBPMNElements(elem.childLaneSet, elem);
			}
		} 
	}
}

rule BPMNCompensateEventDefinitionConnector(elem: OclAny) {
	do {
		if (elem.oclIsKindOf(LPAD!CompensateEventDefinition)) {
			if (not elem.activityRef.oclIsUndefined()) { 
				thisModule.connectBPMNElements(elem, elem.activityRef);
				thisModule.connectBPMNElements(elem.activityRef, elem);
			}
		}
	}
}

rule BPMNTaskConnector(elem: OclAny) {
	do {
		if (elem.oclIsKindOf(LPAD!Task)) {
			for (t in elem.documentsAndResources) {
				thisModule.connectBPMNElements(elem, t);
				thisModule.connectBPMNElements(t, elem);
			}
		}
	}
}

rule BPMNFlowNodeConnector(elem: OclAny) {
	do {
		if (elem.oclIsKindOf(LPAD!FlowNode)) {
			for (t in elem.lanes) {
				thisModule.connectBPMNElements(elem, t);
				thisModule.connectBPMNElements(t, elem);
			}
		}
	}
}

------------------------  Competency2MODELType  ---------------------------
rule Competency2MODELType {
	from
		s: LPAD!CompetencyModel
	to
		t: ADOXX!MODELType(
			id <- s.id,
			name <- s.name,
			version <- s.getVersion,
			applib <- 'LearnPAd', 
			libtype <- 'bp',
			modeltype <- thisModule.mapModelType.get('cm'),
			mODELATTRIBUTES <- Sequence{m}
		),
		m: ADOXX!MODELATTRIBUTESType(
			aTTRIBUTE <- Sequence{a}
		),
		a: ADOXX!ATTRIBUTEType (
			name <- 'Description',
			type <- 'STRING',
			value <- ''
		),
		iref: ADOXX!IREFType(
			tmodelname <- s.name,
			tmodeltype <- thisModule.mapModelType.get('cm'),
			type <- 'modelreference',
			tmodelver <- s.getVersion
		)
	do {
		thisModule.modelsType.mODEL <- thisModule.modelsType.mODEL.append(t);
		
		--append the iref definition to the model set overview reference
		thisModule.overviewModels.iREF <- thisModule.overviewModels.iREF.append(iref);
	}
}

-------------------------  Competency Group ------------------------------
rule CompetencyGroup2InstanceType {
	from
		s: LPAD!CompetencyGroup ((thisModule.processedCompetencyElementType.includes(s.getType)) and 
			(not s.name.oclIsUndefined()) 
			and (s.name.toString()<>''))			
	to
		i: ADOXX!INSTANCEType (
			class <- s.getType,
			id <- s.id,
			name <- s.name,
			aTTRIBUTE <- Sequence{a}
		),
		a: ADOXX!ATTRIBUTEType (
			name <- 'Description',
			type <- 'STRING',
			value <- s.description
		)
	do {
			--set the instances to parent model
			s.getParentMODELType.iNSTANCE <- i;	
			
			--relations from Competency Group
			thisModule.CompetencyGroup(s);
		}
}	

-----------------------  Competency Competency ----------------------------
rule Competency2InstanceType {
	from
		s: LPAD!Competency ((thisModule.processedCompetencyElementType.includes(s.getType)) and 
			(not s.name.oclIsUndefined()) 
			and (s.name.toString()<>''))			
	to
		i: ADOXX!INSTANCEType (
			class <- s.getType,
			id <- s.id,
			name <- s.name,
			aTTRIBUTE <- Sequence{a1, a2, a3, a4, a5}
		),
		a1: ADOXX!ATTRIBUTEType (
			name <- 'Description',
			type <- 'STRING',
			value <- s.description
		),
		a2: ADOXX!ATTRIBUTEType (
			name <- 'EQF Level',
			type <- 'STRING',
			value <- s.EQFLevel.toString()
		),
		a3: ADOXX!ATTRIBUTEType (
			name <- 'EQF Competence',
			type <- 'STRING',
			value <- s.EQFCompetence
		),
		a4: ADOXX!ATTRIBUTEType (
			name <- 'EQF Skill',
			type <- 'STRING',
			value <- s.EQFSkill
		),
		a5: ADOXX!ATTRIBUTEType (
			name <- 'EQF Knowledge',
			type <- 'STRING',
			value <- s.EQFKnowledge
		)
	do {
			--set the instances to parent model
			s.getParentMODELType.iNSTANCE <- i;	
		}
}	

------------------  relations among CompetencyElements ---------------------
helper def: connectCompetencyElements(source: OclAny, target: OclAny): Boolean =
	if ((not source.name.oclIsUndefined()) and (source.name.toString()<>'')) and
	((not target.name.oclIsUndefined()) and (target.name.toString()<>'')) and
	(thisModule.processedCompetencyElementType.includes(source.getType)) and
	(thisModule.processedCompetencyElementType.includes(target.getType)) then
		thisModule.createInsideConnector(source, target)
	else
		false
	endif;

-----------------  Competency Is inside relation rules  --------------------

rule CompetencyGroup(elem: OclAny) {
	do {
		if (elem.oclIsKindOf(LPAD!CompetencyGroup)) {
			for (t in elem.belongs) {
				thisModule.connectCompetencyElements(t, elem);
			}
		}
	}
}


-----------------------  Organizational2MODELType  -------------------------
rule Organizational2MODELType {
	from
		s: LPAD!OrganisationalModel
	to
		t: ADOXX!MODELType(
			id <- s.id,
			name <- s.name,
			version <- s.getVersion,
			applib <- 'LearnPAd', 
			libtype <- 'bp',
			modeltype <- thisModule.mapModelType.get('os'),
			mODELATTRIBUTES <- Sequence{m}
		),
		m: ADOXX!MODELATTRIBUTESType(
			aTTRIBUTE <- Sequence{a}
		),
		a: ADOXX!ATTRIBUTEType (
			name <- 'Description',
			type <- 'STRING',
			value <- ''
		),
		iref: ADOXX!IREFType(
			tmodelname <- s.name,
			tmodeltype <- thisModule.mapModelType.get('os'),
			type <- 'modelreference',
			tmodelver <- s.getVersion
		)
	do {
		thisModule.modelsType.mODEL <- thisModule.modelsType.mODEL.append(t);
		
		--append the iref definition to the model set overview reference
		thisModule.overviewModels.iREF <- thisModule.overviewModels.iREF.append(iref);
	}
}

------------------------  DocumentAndKnowledge2MODELType  ---------------------------
rule DocumentAndKnowledge2MODELType {
	from
		s: LPAD!DKModel
	to
		t: ADOXX!MODELType(
			id <- s.id,
			name <- s.name,
			version <- s.getVersion,
			applib <- 'LearnPAd', 
			libtype <- 'bp',
			modeltype <- thisModule.mapModelType.get('dkm'),
			mODELATTRIBUTES <- Sequence{m}
		),
		m: ADOXX!MODELATTRIBUTESType(
			aTTRIBUTE <- Sequence{a}
		),
		a: ADOXX!ATTRIBUTEType (
			name <- 'Description',
			type <- 'STRING',
			value <- ''
		),
		iref: ADOXX!IREFType(
			tmodelname <- s.name,
			tmodeltype <- thisModule.mapModelType.get('dkm'),
			type <- 'modelreference',
			tmodelver <- s.getVersion
		)
	do {
		thisModule.modelsType.mODEL <- thisModule.modelsType.mODEL.append(t);
		
		--append the iref definition to the model set overview reference
		thisModule.overviewModels.iREF <- thisModule.overviewModels.iREF.append(iref);
	}
}

-------------------------  Document Group ------------------------------
rule Groups2InstanceType {
	from
		s: LPAD!Groups ((thisModule.processedDocumenntElementType.includes(s.getType)) and 
			(not s.name.oclIsUndefined()) 
			and (s.name.toString()<>''))			
	to
		i: ADOXX!INSTANCEType (
			class <- s.getType,
			id <- s.id,
			name <- s.name,
			aTTRIBUTE <- Sequence{a}
		),
		a: ADOXX!ATTRIBUTEType (
			name <- 'Description',
			type <- 'STRING',
			value <- s.description
		)
	do {
			--set the instances to parent model
			s.getParentMODELType.iNSTANCE <- i;	
			
			--relations from Competency Group
			thisModule.DocumentGroup(s);
		}
}	

-----------------------  Competency Competency ----------------------------
rule Document2InstanceType {
	from
		s: LPAD!Document ((thisModule.processedDocumenntElementType.includes(s.getType)) and 
			(not s.name.oclIsUndefined()) 
			and (s.name.toString()<>''))			
	to
		i: ADOXX!INSTANCEType (
			class <- s.getType,
			id <- s.id,
			name <- s.name,
			aTTRIBUTE <- Sequence{a1}
		),
		a1: ADOXX!ATTRIBUTEType (
			name <- 'Description',
			type <- 'STRING',
			value <- s.description
		)
	do {
			--set the instances to parent model
			s.getParentMODELType.iNSTANCE <- i;	
		}
}	

------------------  relations among CompetencyElements ---------------------
helper def: connectDocumentsElements(source: OclAny, target: OclAny): Boolean =
	if ((not source.name.oclIsUndefined()) and (source.name.toString()<>'')) and
	((not target.name.oclIsUndefined()) and (target.name.toString()<>'')) and
	(thisModule.processedDocumenntElementType.includes(source.getType)) and
	(thisModule.processedDocumenntElementType.includes(target.getType)) then
		thisModule.createInsideConnector(source, target)
	else
		false
	endif;

-----------------  Competency Is inside relation rules  --------------------

rule DocumentGroup(elem: OclAny) {
	do {
		if (elem.oclIsKindOf(LPAD!Groups)) {
			for (t in elem.documents) {
				thisModule.connectDocumentsElements(t, elem);
			}
		}
	}
}
